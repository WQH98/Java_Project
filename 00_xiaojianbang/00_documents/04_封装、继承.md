#### 封装

##### 1、封装的概念

​		隐藏对象的属性和方法实现细节 仅对外公开用于才做内部数据的接口 控制程序中属性的读和修改的访问级别 比如你买了电脑 你会使用它 但你不知道它是如何运行的

##### 2、封装的好处

​		隐藏实现细节 使用的人只需知道传入什么参数 会产生什么效果 返回什么数据
​		对属性进行操作时 可以验证传入数据的合理性
​		把属性私有 定义公开的get、set方法来验证数据合理性

##### 3、练习

​		定义Account类 要求具有属性：姓名name（长度为2-4 初始化后不可修改）、余额balance（必须大于20）、密码password（必须是6位） 如果不满足 则给出提示信息 并给默认值（自己定）

#### 继承

##### 1、为什么需要继承？

​		提高代码复用性
​		继承是多态的前提

##### 2、继承的注意事项

​		1、继承的语法			

```java
class 子类 extends 父类()
```

​		2、父类/超类/基类
​			  子类/派生类
​		3、当多个类存在相同的属性和方法时 可以从这些类中抽象出父类 在父类中定义这些相同的属性和方法 所有的子类不需要重新定义这些属性和方法 只需要通过extends来声明继承父类即可
​		4、子类自动拥有父类的所有属性和方法(受访问修饰符影响)
​		5、受访问修饰符影响 子类不能访问父类的属性和方法 可以通过父类的公开方法去访问 类似封装
​		6、java是单继承机制 子类最多只能继承一个父类(指直接继承) 但是可以实现多个接口
​		7、所有类都是Object的子类
​		8、多层继承 查看关系

#### 父类构造器

​		1、当创建子类对象时 不管使用子类的哪个构造器 默认情况下总会去调用父类的无参构造器super()
​		2、如果父类没有提供无参构造器 则需在子类构造器中用super去指定使用父类的哪个构造器
​				super(参数列表)
​				super()和this()都只能放在构造器第一行 因此这两个方法不能共存在一个构造器
​		3、父类构造器的调用不限于直接父类 一直往上追溯到Object类(顶级父类)

#### super

​		1、为什么需要super？
​				a)、子类和父类具有同名属性和方法时 默认使用子类的同名属性和方法 为了访问父类的属性和方法 必须通过super来调用
​				b)、super代表父类对象的引用 用于访问父类对象的属性、方法、构造器
​		2、访问父类的属性(受访问修饰符影响)
​				super.属性名;
​		3、访问父类的方法(受访问修饰符影响)
​				super.方法名(参数列表);
​		4、访问父类的构造器
​				super(参数列表)

#### 方法重写

​		1、为什么需要重写？
​		2、子类可以重写父类属性和方法
​		3、方法重写特点
​				a)、方法重写也叫方法覆盖
​				b)、子类方法的名称、参数，与父类完全相同
​				c)、子类方法的返回类型和父类方法返回类型一样 或者是父类返回类型的子类
​					   比如父类返回类型是Object 子类方法返回类型是String
​				d)、子类方法不能缩小父类方法的访问权限
​		4、重载与重写的区别？
​				重载：在一个类中 方法名相同 但参数类型、个数或顺序不同 与返回值无关 与修饰符无关
​				重写：父类和子类中 方法名相同 参数相同 子类返回类型与父类一样或者是其子类 子类不能缩小父						   类的访问范围